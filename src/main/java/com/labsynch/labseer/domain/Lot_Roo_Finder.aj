// WARNING: DO NOT EDIT THIS FILE. THIS FILE IS MANAGED BY SPRING ROO.
// You may push code into the target .java compilation unit if you wish to edit any member(s).

package com.labsynch.labseer.domain;

import com.labsynch.labseer.domain.BulkLoadFile;
import com.labsynch.labseer.domain.Lot;
import com.labsynch.labseer.domain.SaltForm;
import java.util.Date;
import javax.persistence.EntityManager;
import javax.persistence.TypedQuery;

privileged aspect Lot_Roo_Finder {
    
    public static Long Lot.countFindLotsByBuid(Long buid) {
        if (buid == null) throw new IllegalArgumentException("The buid argument is required");
        EntityManager em = Lot.entityManager();
        TypedQuery q = em.createQuery("SELECT COUNT(o) FROM Lot AS o WHERE o.buid = :buid", Long.class);
        q.setParameter("buid", buid);
        return ((Long) q.getSingleResult());
    }
    
    public static Long Lot.countFindLotsByBulkLoadFileEquals(BulkLoadFile bulkLoadFile) {
        if (bulkLoadFile == null) throw new IllegalArgumentException("The bulkLoadFile argument is required");
        EntityManager em = Lot.entityManager();
        TypedQuery q = em.createQuery("SELECT COUNT(o) FROM Lot AS o WHERE o.bulkLoadFile = :bulkLoadFile", Long.class);
        q.setParameter("bulkLoadFile", bulkLoadFile);
        return ((Long) q.getSingleResult());
    }
    
    public static Long Lot.countFindLotsByChemistAndSynthesisDateBetween(String chemist, Date minSynthesisDate, Date maxSynthesisDate) {
        if (chemist == null || chemist.length() == 0) throw new IllegalArgumentException("The chemist argument is required");
        if (minSynthesisDate == null) throw new IllegalArgumentException("The minSynthesisDate argument is required");
        if (maxSynthesisDate == null) throw new IllegalArgumentException("The maxSynthesisDate argument is required");
        EntityManager em = Lot.entityManager();
        TypedQuery q = em.createQuery("SELECT COUNT(o) FROM Lot AS o WHERE o.chemist = :chemist AND o.synthesisDate BETWEEN :minSynthesisDate AND :maxSynthesisDate", Long.class);
        q.setParameter("chemist", chemist);
        q.setParameter("minSynthesisDate", minSynthesisDate);
        q.setParameter("maxSynthesisDate", maxSynthesisDate);
        return ((Long) q.getSingleResult());
    }
    
    public static Long Lot.countFindLotsByCorpNameEquals(String corpName) {
        if (corpName == null || corpName.length() == 0) throw new IllegalArgumentException("The corpName argument is required");
        EntityManager em = Lot.entityManager();
        TypedQuery q = em.createQuery("SELECT COUNT(o) FROM Lot AS o WHERE o.corpName = :corpName", Long.class);
        q.setParameter("corpName", corpName);
        return ((Long) q.getSingleResult());
    }
    
    public static Long Lot.countFindLotsByCorpNameLike(String corpName) {
        if (corpName == null || corpName.length() == 0) throw new IllegalArgumentException("The corpName argument is required");
        corpName = corpName.replace('*', '%');
        if (corpName.charAt(0) != '%') {
            corpName = "%" + corpName;
        }
        if (corpName.charAt(corpName.length() - 1) != '%') {
            corpName = corpName + "%";
        }
        EntityManager em = Lot.entityManager();
        TypedQuery q = em.createQuery("SELECT COUNT(o) FROM Lot AS o WHERE LOWER(o.corpName) LIKE LOWER(:corpName)", Long.class);
        q.setParameter("corpName", corpName);
        return ((Long) q.getSingleResult());
    }
    
    public static Long Lot.countFindLotsByIsVirtualNot(Boolean isVirtual) {
        if (isVirtual == null) throw new IllegalArgumentException("The isVirtual argument is required");
        EntityManager em = Lot.entityManager();
        TypedQuery q = em.createQuery("SELECT COUNT(o) FROM Lot AS o WHERE o.isVirtual IS NOT :isVirtual", Long.class);
        q.setParameter("isVirtual", isVirtual);
        return ((Long) q.getSingleResult());
    }
    
    public static Long Lot.countFindLotsByNotebookPageEquals(String notebookPage) {
        if (notebookPage == null || notebookPage.length() == 0) throw new IllegalArgumentException("The notebookPage argument is required");
        EntityManager em = Lot.entityManager();
        TypedQuery q = em.createQuery("SELECT COUNT(o) FROM Lot AS o WHERE o.notebookPage = :notebookPage", Long.class);
        q.setParameter("notebookPage", notebookPage);
        return ((Long) q.getSingleResult());
    }
    
    public static Long Lot.countFindLotsByNotebookPageEqualsAndIgnoreNot(String notebookPage, Boolean ignore) {
        if (notebookPage == null || notebookPage.length() == 0) throw new IllegalArgumentException("The notebookPage argument is required");
        if (ignore == null) throw new IllegalArgumentException("The ignore argument is required");
        EntityManager em = Lot.entityManager();
        TypedQuery q = em.createQuery("SELECT COUNT(o) FROM Lot AS o WHERE o.notebookPage = :notebookPage  AND o.ignore IS NOT :ignore", Long.class);
        q.setParameter("notebookPage", notebookPage);
        q.setParameter("ignore", ignore);
        return ((Long) q.getSingleResult());
    }
    
    public static Long Lot.countFindLotsBySaltForm(SaltForm saltForm) {
        if (saltForm == null) throw new IllegalArgumentException("The saltForm argument is required");
        EntityManager em = Lot.entityManager();
        TypedQuery q = em.createQuery("SELECT COUNT(o) FROM Lot AS o WHERE o.saltForm = :saltForm", Long.class);
        q.setParameter("saltForm", saltForm);
        return ((Long) q.getSingleResult());
    }
    
    public static Long Lot.countFindLotsBySynthesisDateBetween(Date minSynthesisDate, Date maxSynthesisDate) {
        if (minSynthesisDate == null) throw new IllegalArgumentException("The minSynthesisDate argument is required");
        if (maxSynthesisDate == null) throw new IllegalArgumentException("The maxSynthesisDate argument is required");
        EntityManager em = Lot.entityManager();
        TypedQuery q = em.createQuery("SELECT COUNT(o) FROM Lot AS o WHERE o.synthesisDate BETWEEN :minSynthesisDate AND :maxSynthesisDate", Long.class);
        q.setParameter("minSynthesisDate", minSynthesisDate);
        q.setParameter("maxSynthesisDate", maxSynthesisDate);
        return ((Long) q.getSingleResult());
    }
    
    public static Long Lot.countFindLotsBySynthesisDateGreaterThan(Date synthesisDate) {
        if (synthesisDate == null) throw new IllegalArgumentException("The synthesisDate argument is required");
        EntityManager em = Lot.entityManager();
        TypedQuery q = em.createQuery("SELECT COUNT(o) FROM Lot AS o WHERE o.synthesisDate > :synthesisDate", Long.class);
        q.setParameter("synthesisDate", synthesisDate);
        return ((Long) q.getSingleResult());
    }
    
    public static Long Lot.countFindLotsBySynthesisDateLessThan(Date synthesisDate) {
        if (synthesisDate == null) throw new IllegalArgumentException("The synthesisDate argument is required");
        EntityManager em = Lot.entityManager();
        TypedQuery q = em.createQuery("SELECT COUNT(o) FROM Lot AS o WHERE o.synthesisDate < :synthesisDate", Long.class);
        q.setParameter("synthesisDate", synthesisDate);
        return ((Long) q.getSingleResult());
    }
    
    public static TypedQuery<Lot> Lot.findLotsByBuid(Long buid) {
        if (buid == null) throw new IllegalArgumentException("The buid argument is required");
        EntityManager em = Lot.entityManager();
        TypedQuery<Lot> q = em.createQuery("SELECT o FROM Lot AS o WHERE o.buid = :buid", Lot.class);
        q.setParameter("buid", buid);
        return q;
    }
    
    public static TypedQuery<Lot> Lot.findLotsByBuid(Long buid, String sortFieldName, String sortOrder) {
        if (buid == null) throw new IllegalArgumentException("The buid argument is required");
        EntityManager em = Lot.entityManager();
        StringBuilder queryBuilder = new StringBuilder("SELECT o FROM Lot AS o WHERE o.buid = :buid");
        if (fieldNames4OrderClauseFilter.contains(sortFieldName)) {
            queryBuilder.append(" ORDER BY ").append(sortFieldName);
            if ("ASC".equalsIgnoreCase(sortOrder) || "DESC".equalsIgnoreCase(sortOrder)) {
                queryBuilder.append(" ").append(sortOrder);
            }
        }
        TypedQuery<Lot> q = em.createQuery(queryBuilder.toString(), Lot.class);
        q.setParameter("buid", buid);
        return q;
    }
    
    public static TypedQuery<Lot> Lot.findLotsByBulkLoadFileEquals(BulkLoadFile bulkLoadFile) {
        if (bulkLoadFile == null) throw new IllegalArgumentException("The bulkLoadFile argument is required");
        EntityManager em = Lot.entityManager();
        TypedQuery<Lot> q = em.createQuery("SELECT o FROM Lot AS o WHERE o.bulkLoadFile = :bulkLoadFile", Lot.class);
        q.setParameter("bulkLoadFile", bulkLoadFile);
        return q;
    }
    
    public static TypedQuery<Lot> Lot.findLotsByBulkLoadFileEquals(BulkLoadFile bulkLoadFile, String sortFieldName, String sortOrder) {
        if (bulkLoadFile == null) throw new IllegalArgumentException("The bulkLoadFile argument is required");
        EntityManager em = Lot.entityManager();
        StringBuilder queryBuilder = new StringBuilder("SELECT o FROM Lot AS o WHERE o.bulkLoadFile = :bulkLoadFile");
        if (fieldNames4OrderClauseFilter.contains(sortFieldName)) {
            queryBuilder.append(" ORDER BY ").append(sortFieldName);
            if ("ASC".equalsIgnoreCase(sortOrder) || "DESC".equalsIgnoreCase(sortOrder)) {
                queryBuilder.append(" ").append(sortOrder);
            }
        }
        TypedQuery<Lot> q = em.createQuery(queryBuilder.toString(), Lot.class);
        q.setParameter("bulkLoadFile", bulkLoadFile);
        return q;
    }
    
    public static TypedQuery<Lot> Lot.findLotsByChemistAndSynthesisDateBetween(String chemist, Date minSynthesisDate, Date maxSynthesisDate) {
        if (chemist == null || chemist.length() == 0) throw new IllegalArgumentException("The chemist argument is required");
        if (minSynthesisDate == null) throw new IllegalArgumentException("The minSynthesisDate argument is required");
        if (maxSynthesisDate == null) throw new IllegalArgumentException("The maxSynthesisDate argument is required");
        EntityManager em = Lot.entityManager();
        TypedQuery<Lot> q = em.createQuery("SELECT o FROM Lot AS o WHERE o.chemist = :chemist AND o.synthesisDate BETWEEN :minSynthesisDate AND :maxSynthesisDate", Lot.class);
        q.setParameter("chemist", chemist);
        q.setParameter("minSynthesisDate", minSynthesisDate);
        q.setParameter("maxSynthesisDate", maxSynthesisDate);
        return q;
    }
    
    public static TypedQuery<Lot> Lot.findLotsByChemistAndSynthesisDateBetween(String chemist, Date minSynthesisDate, Date maxSynthesisDate, String sortFieldName, String sortOrder) {
        if (chemist == null || chemist.length() == 0) throw new IllegalArgumentException("The chemist argument is required");
        if (minSynthesisDate == null) throw new IllegalArgumentException("The minSynthesisDate argument is required");
        if (maxSynthesisDate == null) throw new IllegalArgumentException("The maxSynthesisDate argument is required");
        EntityManager em = Lot.entityManager();
        StringBuilder queryBuilder = new StringBuilder("SELECT o FROM Lot AS o WHERE o.chemist = :chemist AND o.synthesisDate BETWEEN :minSynthesisDate AND :maxSynthesisDate");
        if (fieldNames4OrderClauseFilter.contains(sortFieldName)) {
            queryBuilder.append(" ORDER BY ").append(sortFieldName);
            if ("ASC".equalsIgnoreCase(sortOrder) || "DESC".equalsIgnoreCase(sortOrder)) {
                queryBuilder.append(" ").append(sortOrder);
            }
        }
        TypedQuery<Lot> q = em.createQuery(queryBuilder.toString(), Lot.class);
        q.setParameter("chemist", chemist);
        q.setParameter("minSynthesisDate", minSynthesisDate);
        q.setParameter("maxSynthesisDate", maxSynthesisDate);
        return q;
    }
    
    public static TypedQuery<Lot> Lot.findLotsByCorpNameEquals(String corpName) {
        if (corpName == null || corpName.length() == 0) throw new IllegalArgumentException("The corpName argument is required");
        EntityManager em = Lot.entityManager();
        TypedQuery<Lot> q = em.createQuery("SELECT o FROM Lot AS o WHERE o.corpName = :corpName", Lot.class);
        q.setParameter("corpName", corpName);
        return q;
    }
    
    public static TypedQuery<Lot> Lot.findLotsByCorpNameEquals(String corpName, String sortFieldName, String sortOrder) {
        if (corpName == null || corpName.length() == 0) throw new IllegalArgumentException("The corpName argument is required");
        EntityManager em = Lot.entityManager();
        StringBuilder queryBuilder = new StringBuilder("SELECT o FROM Lot AS o WHERE o.corpName = :corpName");
        if (fieldNames4OrderClauseFilter.contains(sortFieldName)) {
            queryBuilder.append(" ORDER BY ").append(sortFieldName);
            if ("ASC".equalsIgnoreCase(sortOrder) || "DESC".equalsIgnoreCase(sortOrder)) {
                queryBuilder.append(" ").append(sortOrder);
            }
        }
        TypedQuery<Lot> q = em.createQuery(queryBuilder.toString(), Lot.class);
        q.setParameter("corpName", corpName);
        return q;
    }
    
    public static TypedQuery<Lot> Lot.findLotsByCorpNameLike(String corpName) {
        if (corpName == null || corpName.length() == 0) throw new IllegalArgumentException("The corpName argument is required");
        corpName = corpName.replace('*', '%');
        if (corpName.charAt(0) != '%') {
            corpName = "%" + corpName;
        }
        if (corpName.charAt(corpName.length() - 1) != '%') {
            corpName = corpName + "%";
        }
        EntityManager em = Lot.entityManager();
        TypedQuery<Lot> q = em.createQuery("SELECT o FROM Lot AS o WHERE LOWER(o.corpName) LIKE LOWER(:corpName)", Lot.class);
        q.setParameter("corpName", corpName);
        return q;
    }
    
    public static TypedQuery<Lot> Lot.findLotsByCorpNameLike(String corpName, String sortFieldName, String sortOrder) {
        if (corpName == null || corpName.length() == 0) throw new IllegalArgumentException("The corpName argument is required");
        corpName = corpName.replace('*', '%');
        if (corpName.charAt(0) != '%') {
            corpName = "%" + corpName;
        }
        if (corpName.charAt(corpName.length() - 1) != '%') {
            corpName = corpName + "%";
        }
        EntityManager em = Lot.entityManager();
        StringBuilder queryBuilder = new StringBuilder("SELECT o FROM Lot AS o WHERE LOWER(o.corpName) LIKE LOWER(:corpName)");
        if (fieldNames4OrderClauseFilter.contains(sortFieldName)) {
            queryBuilder.append(" ORDER BY ").append(sortFieldName);
            if ("ASC".equalsIgnoreCase(sortOrder) || "DESC".equalsIgnoreCase(sortOrder)) {
                queryBuilder.append(" ").append(sortOrder);
            }
        }
        TypedQuery<Lot> q = em.createQuery(queryBuilder.toString(), Lot.class);
        q.setParameter("corpName", corpName);
        return q;
    }
    
    public static TypedQuery<Lot> Lot.findLotsByIsVirtualNot(Boolean isVirtual) {
        if (isVirtual == null) throw new IllegalArgumentException("The isVirtual argument is required");
        EntityManager em = Lot.entityManager();
        TypedQuery<Lot> q = em.createQuery("SELECT o FROM Lot AS o WHERE o.isVirtual IS NOT :isVirtual", Lot.class);
        q.setParameter("isVirtual", isVirtual);
        return q;
    }
    
    public static TypedQuery<Lot> Lot.findLotsByIsVirtualNot(Boolean isVirtual, String sortFieldName, String sortOrder) {
        if (isVirtual == null) throw new IllegalArgumentException("The isVirtual argument is required");
        EntityManager em = Lot.entityManager();
        StringBuilder queryBuilder = new StringBuilder("SELECT o FROM Lot AS o WHERE o.isVirtual IS NOT :isVirtual");
        if (fieldNames4OrderClauseFilter.contains(sortFieldName)) {
            queryBuilder.append(" ORDER BY ").append(sortFieldName);
            if ("ASC".equalsIgnoreCase(sortOrder) || "DESC".equalsIgnoreCase(sortOrder)) {
                queryBuilder.append(" ").append(sortOrder);
            }
        }
        TypedQuery<Lot> q = em.createQuery(queryBuilder.toString(), Lot.class);
        q.setParameter("isVirtual", isVirtual);
        return q;
    }
    
    public static TypedQuery<Lot> Lot.findLotsByNotebookPageEquals(String notebookPage, String sortFieldName, String sortOrder) {
        if (notebookPage == null || notebookPage.length() == 0) throw new IllegalArgumentException("The notebookPage argument is required");
        EntityManager em = Lot.entityManager();
        StringBuilder queryBuilder = new StringBuilder("SELECT o FROM Lot AS o WHERE o.notebookPage = :notebookPage");
        if (fieldNames4OrderClauseFilter.contains(sortFieldName)) {
            queryBuilder.append(" ORDER BY ").append(sortFieldName);
            if ("ASC".equalsIgnoreCase(sortOrder) || "DESC".equalsIgnoreCase(sortOrder)) {
                queryBuilder.append(" ").append(sortOrder);
            }
        }
        TypedQuery<Lot> q = em.createQuery(queryBuilder.toString(), Lot.class);
        q.setParameter("notebookPage", notebookPage);
        return q;
    }
    
    public static TypedQuery<Lot> Lot.findLotsByNotebookPageEqualsAndIgnoreNot(String notebookPage, Boolean ignore) {
        if (notebookPage == null || notebookPage.length() == 0) throw new IllegalArgumentException("The notebookPage argument is required");
        if (ignore == null) throw new IllegalArgumentException("The ignore argument is required");
        EntityManager em = Lot.entityManager();
        TypedQuery<Lot> q = em.createQuery("SELECT o FROM Lot AS o WHERE o.notebookPage = :notebookPage  AND o.ignore IS NOT :ignore", Lot.class);
        q.setParameter("notebookPage", notebookPage);
        q.setParameter("ignore", ignore);
        return q;
    }
    
    public static TypedQuery<Lot> Lot.findLotsByNotebookPageEqualsAndIgnoreNot(String notebookPage, Boolean ignore, String sortFieldName, String sortOrder) {
        if (notebookPage == null || notebookPage.length() == 0) throw new IllegalArgumentException("The notebookPage argument is required");
        if (ignore == null) throw new IllegalArgumentException("The ignore argument is required");
        EntityManager em = Lot.entityManager();
        StringBuilder queryBuilder = new StringBuilder("SELECT o FROM Lot AS o WHERE o.notebookPage = :notebookPage  AND o.ignore IS NOT :ignore");
        if (fieldNames4OrderClauseFilter.contains(sortFieldName)) {
            queryBuilder.append(" ORDER BY ").append(sortFieldName);
            if ("ASC".equalsIgnoreCase(sortOrder) || "DESC".equalsIgnoreCase(sortOrder)) {
                queryBuilder.append(" ").append(sortOrder);
            }
        }
        TypedQuery<Lot> q = em.createQuery(queryBuilder.toString(), Lot.class);
        q.setParameter("notebookPage", notebookPage);
        q.setParameter("ignore", ignore);
        return q;
    }
    
    public static TypedQuery<Lot> Lot.findLotsBySaltForm(SaltForm saltForm, String sortFieldName, String sortOrder) {
        if (saltForm == null) throw new IllegalArgumentException("The saltForm argument is required");
        EntityManager em = Lot.entityManager();
        StringBuilder queryBuilder = new StringBuilder("SELECT o FROM Lot AS o WHERE o.saltForm = :saltForm");
        if (fieldNames4OrderClauseFilter.contains(sortFieldName)) {
            queryBuilder.append(" ORDER BY ").append(sortFieldName);
            if ("ASC".equalsIgnoreCase(sortOrder) || "DESC".equalsIgnoreCase(sortOrder)) {
                queryBuilder.append(" ").append(sortOrder);
            }
        }
        TypedQuery<Lot> q = em.createQuery(queryBuilder.toString(), Lot.class);
        q.setParameter("saltForm", saltForm);
        return q;
    }
    
    public static TypedQuery<Lot> Lot.findLotsBySynthesisDateBetween(Date minSynthesisDate, Date maxSynthesisDate) {
        if (minSynthesisDate == null) throw new IllegalArgumentException("The minSynthesisDate argument is required");
        if (maxSynthesisDate == null) throw new IllegalArgumentException("The maxSynthesisDate argument is required");
        EntityManager em = Lot.entityManager();
        TypedQuery<Lot> q = em.createQuery("SELECT o FROM Lot AS o WHERE o.synthesisDate BETWEEN :minSynthesisDate AND :maxSynthesisDate", Lot.class);
        q.setParameter("minSynthesisDate", minSynthesisDate);
        q.setParameter("maxSynthesisDate", maxSynthesisDate);
        return q;
    }
    
    public static TypedQuery<Lot> Lot.findLotsBySynthesisDateBetween(Date minSynthesisDate, Date maxSynthesisDate, String sortFieldName, String sortOrder) {
        if (minSynthesisDate == null) throw new IllegalArgumentException("The minSynthesisDate argument is required");
        if (maxSynthesisDate == null) throw new IllegalArgumentException("The maxSynthesisDate argument is required");
        EntityManager em = Lot.entityManager();
        StringBuilder queryBuilder = new StringBuilder("SELECT o FROM Lot AS o WHERE o.synthesisDate BETWEEN :minSynthesisDate AND :maxSynthesisDate");
        if (fieldNames4OrderClauseFilter.contains(sortFieldName)) {
            queryBuilder.append(" ORDER BY ").append(sortFieldName);
            if ("ASC".equalsIgnoreCase(sortOrder) || "DESC".equalsIgnoreCase(sortOrder)) {
                queryBuilder.append(" ").append(sortOrder);
            }
        }
        TypedQuery<Lot> q = em.createQuery(queryBuilder.toString(), Lot.class);
        q.setParameter("minSynthesisDate", minSynthesisDate);
        q.setParameter("maxSynthesisDate", maxSynthesisDate);
        return q;
    }
    
    public static TypedQuery<Lot> Lot.findLotsBySynthesisDateGreaterThan(Date synthesisDate) {
        if (synthesisDate == null) throw new IllegalArgumentException("The synthesisDate argument is required");
        EntityManager em = Lot.entityManager();
        TypedQuery<Lot> q = em.createQuery("SELECT o FROM Lot AS o WHERE o.synthesisDate > :synthesisDate", Lot.class);
        q.setParameter("synthesisDate", synthesisDate);
        return q;
    }
    
    public static TypedQuery<Lot> Lot.findLotsBySynthesisDateGreaterThan(Date synthesisDate, String sortFieldName, String sortOrder) {
        if (synthesisDate == null) throw new IllegalArgumentException("The synthesisDate argument is required");
        EntityManager em = Lot.entityManager();
        StringBuilder queryBuilder = new StringBuilder("SELECT o FROM Lot AS o WHERE o.synthesisDate > :synthesisDate");
        if (fieldNames4OrderClauseFilter.contains(sortFieldName)) {
            queryBuilder.append(" ORDER BY ").append(sortFieldName);
            if ("ASC".equalsIgnoreCase(sortOrder) || "DESC".equalsIgnoreCase(sortOrder)) {
                queryBuilder.append(" ").append(sortOrder);
            }
        }
        TypedQuery<Lot> q = em.createQuery(queryBuilder.toString(), Lot.class);
        q.setParameter("synthesisDate", synthesisDate);
        return q;
    }
    
    public static TypedQuery<Lot> Lot.findLotsBySynthesisDateLessThan(Date synthesisDate) {
        if (synthesisDate == null) throw new IllegalArgumentException("The synthesisDate argument is required");
        EntityManager em = Lot.entityManager();
        TypedQuery<Lot> q = em.createQuery("SELECT o FROM Lot AS o WHERE o.synthesisDate < :synthesisDate", Lot.class);
        q.setParameter("synthesisDate", synthesisDate);
        return q;
    }
    
    public static TypedQuery<Lot> Lot.findLotsBySynthesisDateLessThan(Date synthesisDate, String sortFieldName, String sortOrder) {
        if (synthesisDate == null) throw new IllegalArgumentException("The synthesisDate argument is required");
        EntityManager em = Lot.entityManager();
        StringBuilder queryBuilder = new StringBuilder("SELECT o FROM Lot AS o WHERE o.synthesisDate < :synthesisDate");
        if (fieldNames4OrderClauseFilter.contains(sortFieldName)) {
            queryBuilder.append(" ORDER BY ").append(sortFieldName);
            if ("ASC".equalsIgnoreCase(sortOrder) || "DESC".equalsIgnoreCase(sortOrder)) {
                queryBuilder.append(" ").append(sortOrder);
            }
        }
        TypedQuery<Lot> q = em.createQuery(queryBuilder.toString(), Lot.class);
        q.setParameter("synthesisDate", synthesisDate);
        return q;
    }
    
}
